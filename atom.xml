<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Celopsの一片净土</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-09T10:13:59.201Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Celops</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统编程学习(1)</title>
    <link href="http://example.com/2023/08/09/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0(1)/"/>
    <id>http://example.com/2023/08/09/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0(1)/</id>
    <published>2023-08-08T16:00:00.000Z</published>
    <updated>2023-08-09T10:13:59.201Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Tab</strong> </p><ul><li>补齐命令</li><li>补齐路径</li><li>显示当前目录下的所有目录</li></ul><p><strong>以下&#x2F;&#x2F;后代表注释</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear  // 清屏  或者按 ctrl + l</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + l   // 中断进程</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + u/k   // 删除光标前/后所有内容</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>     // 切换到当前用户的主目录</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">cd</span> -   // 切换到上一个进入的目录</span><br><span class="line"><span class="built_in">cd</span> /    // 切换到根目录</span><br><span class="line"><span class="built_in">cd</span> ..   // 切换到上一级目录</span><br><span class="line"><span class="built_in">cd</span> ../..    // 切换到上上一级目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>   // 显示当前工作路径</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>   // 列出当前目录下的文件和子目录</span><br><span class="line"><span class="built_in">ls</span> -a  // 列出所有当前目录下的文件和子目录，包括隐藏的</span><br></pre></td></tr></table></figure><p><strong>创建目录</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir_name ... // 创建单个或多个目录</span><br><span class="line"><span class="built_in">mkdir</span> -p /path/to/a/b  // 创建嵌套目录</span><br><span class="line"><span class="built_in">mkdir</span> dir_name&#123;1..100&#125; // 创建目录 dir_name1 ... dir_name100</span><br><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;a    b&quot;</span> // 目录名含有特殊字符时可以用双引号或者转义</span><br></pre></td></tr></table></figure><p><strong>删除目录</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> dir_name </span><br><span class="line">...</span><br><span class="line"><span class="built_in">rm</span> -d dir_name // 删除一个空目录</span><br><span class="line"><span class="built_in">rm</span> -r dir_name // 可以删空或非空目录</span><br></pre></td></tr></table></figure><p><strong>文件类型分类</strong> </p><p>白色：普通文件</p><p>绿色：可执行文件</p><p>红色：压缩文件</p><p>蓝色：目录</p><p>青色：链接文件</p><p>黄色：设备文件</p><p>灰色：其他文件</p><p><strong>通配符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;*&#x27;</span>   // 匹配任意长度的字符</span><br><span class="line"><span class="string">&#x27;?&#x27;</span>   // 匹配任意单个字符</span><br><span class="line"><span class="string">&#x27;[]&#x27;</span>  // 匹配方括号内指定的任意一个字符</span><br><span class="line"><span class="string">&#x27;[-]&#x27;</span> // 匹配方括号内指定范围的字符</span><br><span class="line"><span class="string">&#x27;[^]&#x27;</span> // 匹配方括号内未指定的任意一个字符</span><br><span class="line"><span class="string">&#x27;~&#x27;</span>   // 代表当前用户的主目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 配合 `<span class="built_in">ls</span>` 使用</span><br><span class="line"><span class="built_in">ls</span> pro*  // 查找以pro开头的文件</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 文件相关操作，不能用于目录</span><br><span class="line"><span class="built_in">touch</span> file_name1 file_name2  // 文件存在更新文件访问和时间戳，不存在则创建</span><br><span class="line"><span class="built_in">touch</span> -c file_name      // 文件不存在则创建，存在不会更新已有文件和时间戳</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> file_name1 [...] path   // 拷贝文件到目录，已有同名文件会覆盖</span><br><span class="line"><span class="built_in">cp</span> -i file_name1 [...] path  // 会询问是否覆盖</span><br><span class="line"><span class="built_in">cp</span> -r dir1 dir2    // 拷贝目录到另一目录，默认覆盖</span><br><span class="line"><span class="built_in">cp</span> -rv dir1 dir2   // 显示拷贝进度</span><br><span class="line"><span class="built_in">cp</span> -r -i dir1 dir2  // 询问</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file file2 // 重命名为file2</span><br><span class="line"><span class="built_in">mv</span> file <span class="built_in">dir</span>  // 将file移动到<span class="built_in">dir</span>目录下</span><br><span class="line"><span class="built_in">mv</span> dir1 dir2 // 将dir1目录移动到dir2目录下</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 1.txt  // 将文件内容一次性输出到终端</span><br><span class="line"><span class="built_in">cat</span> -n 1.txt // 按行编号输出，空行也会编号</span><br><span class="line"><span class="built_in">cat</span> -b 1.txt // 按编号输出，编号略过空行</span><br><span class="line"><span class="built_in">cat</span> -A 1.txt // 显示所有信息</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 1.txt // 将内容分页显示到终端</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh 1.txt // 查看文件大小</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h   // 检测文件系统的磁盘空间占用和空余情况</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find path -name <span class="string">&quot;*.txt&quot;</span> // 查找path路径下所有txt文件</span><br><span class="line">find ./ -size +1k/M -size -10k/M // 查找当前目录下大于1k/M小于10k的文件</span><br><span class="line">find ./ -<span class="built_in">type</span> b/c/d/f/s/i/p  // 按文件类型查找</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 对文本进行模式查找，匹配则打印包含模式的所有行</span><br><span class="line">grep <span class="string">&quot;std&quot;</span> path/file_name  // 查找文件中包含std的所有行</span><br><span class="line">grep -n <span class="string">&quot;std&quot;</span> path/file_name  // 选项 -n 显示出现的行号</span><br><span class="line">// -v 所有不包含的行</span><br><span class="line">// -r 在当前目录下所有文件中查询</span><br><span class="line">// -i 忽略大小写</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 管道  一个命令的输出可以作为另一个命令的输入</span><br><span class="line"><span class="built_in">cat</span> 1.cpp | grep <span class="string">&quot;std&quot;</span>  // 从<span class="built_in">cat</span> 1.cpp里查找</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// tar [选项] 打包文件名 文件</span><br><span class="line">tar -cvf test.tar 1.txt 2.txt 3.txt  // 创建归档</span><br><span class="line">tar -xvf test.tar   // 接触归档</span><br><span class="line">tar -tvf test.tar  // 列出归档文件中的内容</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// gzip [-d/r] 要压缩的文件，只能压缩文件，对于目录要先打包成文件</span><br><span class="line">gzip 1.txt  // 不保留原文件的压缩</span><br><span class="line">gzip -d 1.gz // 解压</span><br><span class="line">gzip -r <span class="built_in">dir</span>  // 对目录下所有文件进行压缩</span><br><span class="line">tar -czvf dir.tar.gz <span class="built_in">dir</span>  // 打包并压缩目录</span><br><span class="line">tar -xzvf dir.tar.gz  // 解压</span><br><span class="line">tar -xzvf dir.tar.gz -C path  // 解压到path目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u/o/g/a+/-/=r/w/x file   // 权限设定</span><br><span class="line"><span class="built_in">chmod</span> u+w,g=r,a+r file</span><br><span class="line">// 数字法</span><br><span class="line"><span class="built_in">chmod</span> 751 file  // 文件所有者 同组用户 其他用户</span><br><span class="line"><span class="built_in">chmod</span> -R 777 <span class="built_in">dir</span>  // 递归更改该目录下所有文件的用户权限</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> uer_name file // 修改文件所属者</span><br><span class="line"><span class="built_in">chown</span> :group_name file // 修改文件所属组，两个可以一起设定</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install package_name // 安装软件</span><br><span class="line">sudo apt remove package_name  // 删除软件</span><br><span class="line">sudo apt update  // 更新软件包列表</span><br><span class="line">sudo apt upgrade // 更新已安装的软件包</span><br><span class="line">apt-cache search search_term // 搜索软件包</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 重定向，将输出写入文件中</span><br><span class="line"><span class="built_in">ls</span> &gt; 1.txt // 标准输出，覆盖原有内容</span><br><span class="line"><span class="built_in">ls</span> &gt;&gt; 1.txt // 追加到原有内容之后</span><br><span class="line">tttt 2&gt; 1.txt // 适用错误信息输出</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree [path] // 显示目录树</span><br><span class="line">tree -L number // 最多显示几层</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> a.txt a_link // 创建一个文件的硬链接，和原文件指向同一个内存地址</span><br><span class="line"><span class="built_in">ln</span> -s a.txt [path] a_link // 创建符号链接，存储的是指向源文件的路径</span><br></pre></td></tr></table></figure><h3 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 命令模式下</span><br><span class="line">[num]yy // 复制从当前行开始的num行</span><br><span class="line">p // 粘贴</span><br><span class="line">[num]x // 删除光标后的num个字符</span><br><span class="line">[num]X // 删除光标前的num个字符</span><br><span class="line">D // 删除当前位置到行尾的所有字符</span><br><span class="line">[num]<span class="built_in">dd</span> // 剪贴当前行开始的num行</span><br><span class="line">dG  // 删除光标所在行到文本尾的所有字符</span><br><span class="line">dw  // 删除光标开始位置的单词，包含光标所在字符</span><br><span class="line">d0  // 删除光标开始到行首所有字符</span><br><span class="line">dgg // 删除光标所在行到文本首的所有字符</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u  // 撤销</span><br><span class="line">[num].  // 执行上一次操作 num 次</span><br><span class="line">ctrl + r // 反撤销</span><br><span class="line">ZZ  // 保存退出</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/string  // 从当前光标位置向下查找字符串 n 光标跳到下一个位置， N 上一个位置</span><br><span class="line">?string  // 向下</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r // 替换字符</span><br><span class="line">R // 进入替换模式</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// :进入末行模式，执行后自动回到命令模式</span><br><span class="line">:wq // 保存退出</span><br><span class="line">：x // 保存退出</span><br><span class="line">:w file // 保存到指定文件</span><br><span class="line">:q  // 文件未修改可以退出</span><br><span class="line">:q! // 退出，不保存</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:[st, ed]s/string1/string2/  // 将st到ed行/光标所在行第一次string1改为string2</span><br><span class="line">:[st, ed]s/string1/string2/g // string1全改为string2</span><br><span class="line">:%s/string1/string2/g  // 将文本内所有替换</span><br><span class="line">:%s/string1/string2/gc  // 同上，但每次替换需要确认</span><br><span class="line">:1,<span class="variable">$s</span>/string1/string2/g  // 文本内所有替换</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:sp [file_name] // 水平分屏,不填最后参数和自己分屏，ctrl+w切换窗口</span><br><span class="line">:vsp [file_name] // 垂直分屏，同上</span><br><span class="line">:wall/:wqall/:qall // 保存/保存退出/退出所有窗口</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -O a.cpp b.cpp // 垂直分屏</span><br><span class="line">vim -o a.cpp b.cpp // 水平分屏</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// vim命令模式下使用</span><br><span class="line">:!man <span class="built_in">ls</span>  // 查看手册</span><br><span class="line">:r !<span class="built_in">ls</span> -l // 将<span class="built_in">ls</span> -l执行结果写入到文件中</span><br><span class="line">:r path // 将文件内容写入到当前文件中</span><br><span class="line">:w path // 将当前文件写入到指定文件中</span><br><span class="line">:w! path // 强制</span><br><span class="line">:[st, ed]s<span class="comment">#^#//#g  // 行首加注释</span></span><br><span class="line">:[st, ed]s<span class="comment">#//##g   // 去掉行首注释</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g++ -E a.cpp -o a.i  // 预处理</span><br><span class="line">g++ -S a.i -o a.s   // 编译</span><br><span class="line">g++ -c a.s -o a.o   // 汇编</span><br><span class="line">g++ a.o -o a.exe    // 链接</span><br><span class="line">g++ -o a a.cpp   // 包含上述四步</span><br><span class="line">g++ -Wall  // 显示所有警告</span><br><span class="line">g++ -Wall -Werror a.cpp // 将所有警告当成错误处理</span><br><span class="line">g++ a.cpp -o a -DTAG // 定义宏TAG编译</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-g 包含调试信息</span><br><span class="line">g++ -g -o a a.cpp</span><br><span class="line">-O1/2/3  代码优化</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Tab&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补齐命令&lt;/li&gt;
&lt;li&gt;补齐路径&lt;/li&gt;
&lt;li&gt;显示当前目录下的所有目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;以下&amp;#x2F;&amp;#x2F;后代表注释&lt;/strong&gt;&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LCA</title>
    <link href="http://example.com/2023/05/06/LCA/"/>
    <id>http://example.com/2023/05/06/LCA/</id>
    <published>2023-05-05T16:00:00.000Z</published>
    <updated>2023-05-07T15:35:20.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$\qquad$ LCA (Least Common Ancestors)，即最近公共祖先，这种描述是基于树形结构的。对于 $u, v$ 两点它们的最近公共祖先就是从各自到树根的路径上的第一个共同点，或者说是这两个点的所有公共祖先里离根最远的那个点。</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法:"></a>倍增算法:</h3><p>$\qquad$ 我们定义 $fa[i][j]$ 的含义为点 $i$ 往上走 $2^j$ 步的祖先是谁，可以通过递推求出，预处理复杂度 $O(nlogn)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dep</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fa</span>(n + <span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">22</span>));</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : g[u]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            fa[v][<span class="number">0</span>] = u;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">            fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\qquad$ 有了 $fa$ 数组和点在树中的深度 $dep$ 后，就可以查询两点的 LCA 了，过程如下：</p><p>$\qquad$ 我们先将深度大的点往上跳至两点在同一深度，过程类似二进制拼凑，不妨设深度大的那个点为 $u$ ，还需走 $w$ 步到达同一深度，观察 $w$ 的二进制，要走的步数就是 $w$ 的二进制为 $1$ 的那些位的权值和，从高位往低位循环，设当前位为 $j$，如果 $dep[fa[u][j]] &lt;&#x3D; dep[v]$，因为我们所走的步数的二进制前缀与 $w$ 相同，条件成立说明该位为 $1$ ，就往上跳，最终就可以凑出 $w$ 步。然后将两点同时往上跳，过程与上面类似，判断条件变成如果 $fa[u][j] !&#x3D; fa[v][j]$ 那就往上跳。</p><p>$\qquad$ 很明显查询的复杂度是 $O(logn)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; lca = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v) </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">       <span class="comment">// 跳至同一深度</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">           <span class="keyword">if</span> (dep[fa[u][i]] &gt;= dep[v]) </span><br><span class="line">               v = fa[u][i];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">           <span class="keyword">if</span> (fa[u][i] != fa[v][i]) </span><br><span class="line">u = fa[u][i], v = fa[v][i];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 再往上走一步才是最近公共祖先</span></span><br><span class="line">       <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>$\qquad$ LCA 是满足结合律的，即 $LCA(a, b, c) &#x3D; LCA(LCA(a, b), c)$ ，求多个点的 LCA 就解决了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;$&#92;qquad$ LCA (Least Common Ancestors)，即最近公共祖先，这种描述是基于树形结构的。对于 $u, v$ 两</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>无向图三元环计数</title>
    <link href="http://example.com/2023/05/05/%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/"/>
    <id>http://example.com/2023/05/05/%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/</id>
    <published>2023-05-04T16:00:00.000Z</published>
    <updated>2023-08-09T09:40:42.394Z</updated>
    
    <content type="html"><![CDATA[<p>$\qquad$ 如题，该算法解决的问题就是计算一个无向图中有多少个三元环，采用的思想是根号分治。</p><p>$\qquad$ 考虑给所有边赋予一个方向，具体的，对于原图的每条边将度小的点指向度大的点，度相等的则将编号小的指向编号大的点来建一个新的有向图。由此得到的图是有向无环的。</p><p>$\qquad$ 证明：从一个点出发开始走，途径的点的度一定是非递减的，如果路径上点度都相等，点的编号一定是递增的，则其一定不会指向到达该点的路径上的点，所以新图一定是无环的。</p><p>$\qquad$ 如何计数？原图的三元环在新图中对应为满足 $u \rightarrow v, u \rightarrow w, v \rightarrow w$ 的三个点 $u, v, w$。考虑枚举所有边，这对应第一个条件，再枚举 $u$ 的所有出边，这对应第二个条件，是否满足第三个条件还需要再枚举 $v$ 的所有出边判断，在枚$u$ 的出边时给所有点打上一个时间戳，这样就可以在枚举 $v$  的时候 $O(1)$ 判断是否满足第三个条件。</p><p>复杂度证明：</p><p>$\qquad$ 由上述可得复杂度为 $\sum_{i &#x3D; 1}^m(d_u + d_v)$ , 其中 $d_i$ 表示点 $i$ 在新图中的度，通过分类讨论可以证明 $d_i$ 最大不超过 $\sqrt m$ 。设在原图中点 $i$ 的度数为 $deg_i$ ，当 $deg_u &lt;&#x3D; \sqrt m$ ，自然满足 $d_u &lt;&#x3D; \sqrt m$ 。当 $deg_u &gt; \sqrt m$ 时，由于我们建新图的方式，它在新图中的终点 $v$ 必定满足 $deg_v &gt;&#x3D; deg_u$ ，因为总边数为 $m$ ，则 $v$ 的数量不超过 $\frac{m}{\sqrt m}$ 个，所以复杂度就是 $m \sqrt m$。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> cas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    g = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (n + <span class="number">10</span>);</span><br><span class="line">    set&lt;pii&gt; ens;</span><br><span class="line">    vector&lt;pii&gt; edg;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (u == v || ens.<span class="built_in">count</span>(&#123;u, v&#125;)) <span class="keyword">continue</span>;</span><br><span class="line">        edg.<span class="built_in">pb</span>(&#123;u, v&#125;);</span><br><span class="line">        ens.<span class="built_in">insert</span>(&#123;u, v&#125;);</span><br><span class="line">        d[u]++, d[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edg.<span class="built_in">size</span>(); i++) </span><br><span class="line">        <span class="keyword">if</span> (d[edg[i].fi] &lt;= d[edg[i].se]) g[edg[i].fi].<span class="built_in">pb</span>(edg[i].se);</span><br><span class="line">        <span class="keyword">else</span> g[edg[i].se].<span class="built_in">pb</span>(edg[i].fi);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edg.<span class="built_in">size</span>(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = edg[i].fi, v = edg[i].se;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : g[u]) vis[w] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : g[v]) </span><br><span class="line">            <span class="keyword">if</span> (vis[w] == u) res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$&#92;qquad$ 如题，该算法解决的问题就是计算一个无向图中有多少个三元环，采用的思想是根号分治。&lt;/p&gt;
&lt;p&gt;$&#92;qquad$ 考虑给所有边赋予一个方向，具体的，对于原图的每条边将度小的点指向度大的点，度相等的则将编号小的指向编号大的点来建一个新的有向图。由此得到的图是</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
