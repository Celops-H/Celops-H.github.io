<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Celopsの一片净土</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-17T04:45:51.238Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Celops</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Git管理GitHub仓库</title>
    <link href="http://example.com/2023/08/17/%E4%BD%BF%E7%94%A8Git%E7%AE%A1%E7%90%86GitHub%E4%BB%93%E5%BA%93/"/>
    <id>http://example.com/2023/08/17/%E4%BD%BF%E7%94%A8Git%E7%AE%A1%E7%90%86GitHub%E4%BB%93%E5%BA%93/</id>
    <published>2023-08-16T16:00:00.000Z</published>
    <updated>2023-08-17T04:45:51.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>自行搜索</p><h2 id="绑定Git与GitHub"><a href="#绑定Git与GitHub" class="headerlink" title="绑定Git与GitHub"></a>绑定Git与GitHub</h2><p>打开 <code>git bash</code> ，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>然后按三次回车，这会生成两个文件，提示中有它的目录位置。打开其中的 <code>id_rsa.pub</code> 文件复制其中内容。</p><p>点击<code>github</code> 头像进入 <code>setting</code> ，再从左侧找到 <code>SSH and GPG keys</code> 进入，点击 <code>New SSH key</code> ，粘贴复制的内容然后保存。</p><p>可以用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>检验是否成功。</p><p>如果出现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi your_user_name! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>就是成功了。</p><p>如果出现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;github.com (20.205.243.166)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.</span></span><br><span class="line"><span class="string">This key is not known by any other names.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no/[fingerprint])?</span></span><br></pre></td></tr></table></figure><p>输入 <code>yes</code> 按下回车。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>克隆仓库</strong>：将远程 GitHub 仓库复制到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repository_url&gt;</span><br></pre></td></tr></table></figure><p><strong>添加和提交更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file_name&gt;  <span class="comment"># 将文件添加到暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;Commit message&quot;</span>  <span class="comment"># 提交暂存区的更改到本地仓库</span></span><br></pre></td></tr></table></figure><p><strong>分支管理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;new_branch_name&gt;  <span class="comment"># 创建新分支</span></span><br><span class="line">git checkout &lt;branch_name&gt;  <span class="comment"># 切换到已存在的分支</span></span><br><span class="line">git merge &lt;branch_name&gt;  <span class="comment"># 将一个分支的更改合并到当前分支</span></span><br><span class="line">git branch -d &lt;branch_name&gt;  <span class="comment"># 删除分支（当分支的更改已经合并）</span></span><br></pre></td></tr></table></figure><p><strong>查看状态和历史</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status  <span class="comment"># 查看工作区和暂存区的状态</span></span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看提交历史记录</span></span><br></pre></td></tr></table></figure><p><strong>创建并切换分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new_branch_name&gt;  <span class="comment"># 创建新分支并切换到该分支</span></span><br></pre></td></tr></table></figure><p><strong>撤销更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file_name&gt;  <span class="comment"># 取消暂存区的更改</span></span><br><span class="line">git checkout -- &lt;file_name&gt;  <span class="comment"># 撤销工作区的更改</span></span><br></pre></td></tr></table></figure><p><strong>标签管理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag_name&gt;  <span class="comment"># 创建标签</span></span><br><span class="line">git tag -a &lt;tag_name&gt; -m <span class="string">&quot;Tag message&quot;</span>  <span class="comment"># 创建带有说明的标签</span></span><br><span class="line">git tag  <span class="comment"># 查看标签列表</span></span><br></pre></td></tr></table></figure><p><strong>查看分支图</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --all  <span class="comment"># 查看分支的提交图</span></span><br></pre></td></tr></table></figure><p><strong>远程仓库操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;remote_name&gt; &lt;repository_url&gt;  <span class="comment"># 添加远程仓库链接到本地</span></span><br><span class="line">git remote -v  <span class="comment"># 查看已配置的远程仓库列表</span></span><br><span class="line">git push -u origin &lt;branch_name&gt;  <span class="comment"># 推送并建立分支关联</span></span><br></pre></td></tr></table></figure><p><strong>推送到远程仓库和拉取远程更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch_name&gt;  <span class="comment"># 推送本地分支的更改到远程仓库</span></span><br><span class="line">git pull origin &lt;branch_name&gt;  <span class="comment"># 拉取远程仓库的最新更改到本地</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Git&quot;&gt;&lt;a href=&quot;#安装Git&quot; class=&quot;headerlink&quot; title=&quot;安装Git&quot;&gt;&lt;/a&gt;安装Git&lt;/h2&gt;&lt;p&gt;自行搜索&lt;/p&gt;
&lt;h2 id=&quot;绑定Git与GitHub&quot;&gt;&lt;a href=&quot;#绑定Git与GitHub&quot; cla</summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>极角序</title>
    <link href="http://example.com/2023/08/17/%E6%9E%81%E8%A7%92%E5%BA%8F/"/>
    <id>http://example.com/2023/08/17/%E6%9E%81%E8%A7%92%E5%BA%8F/</id>
    <published>2023-08-16T16:00:00.000Z</published>
    <updated>2023-08-17T04:46:24.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="极角序"><a href="#极角序" class="headerlink" title="极角序"></a>极角序</h1><h2 id="atan2函数"><a href="#atan2函数" class="headerlink" title="atan2函数"></a>atan2函数</h2><p>常数小，但有精度误差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">atan2</span>(a.y,a.x)!=<span class="built_in">atan2</span>(b.y,b.x))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atan2</span>(a.y,a.x)&lt;<span class="built_in">atan2</span>(b.y,b.x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="叉积法"><a href="#叉积法" class="headerlink" title="叉积法"></a>叉积法</h2><p>对整数点无精度损失，排序常数大。</p><p>叉积可以确定两个向量的左右关系，但向量夹角范围是 $[0, \pi]$ ，在一整个平面中无法完成排序，可以将平面分区，$x$ 轴上半部和下半部，原点和 $x$ 轴上左右。</p><p>对于同一区内的采用叉积确定左右关系确定排序，不同区内的根据区的位置排序，比较函数如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">argcmp</span><span class="params">(pot &amp;a, pot &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 确定区，原点为 1 ，x正半轴上为 2，轴上为 3， x 负半轴上为 4，轴下为 5</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> quad = [] (<span class="type">const</span> pot &amp;a) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x == <span class="number">0</span> &amp;&amp; a.y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!a.y) <span class="keyword">return</span> a.x &gt; <span class="number">0</span> ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> a.y &gt; <span class="number">0</span> ? <span class="number">3</span> : <span class="number">5</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> qa = <span class="built_in">quad</span>(a), qb = <span class="built_in">quad</span>(b);</span><br><span class="line">    <span class="keyword">return</span> (qa != qb) ? (qa &lt; qb) : ((a ^ b) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要找夹角最小的两个向量，假设 $a$ 在 $b$ 的逆时针方向，将它们旋转至 $b$ 与 $x$ 轴重合，此时 $a1$ 的坐标为 $(|a|cos \theta, |a|sin \theta)$ ，它们的夹角即为 $a1$ 与极轴的夹角，问题就变成了找与极轴夹角最小的向量，同理叉积即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    pot a = &#123;ve[i] * ve[(i + <span class="number">1</span>) % n], <span class="built_in">abs</span>(ve[i] ^ ve[(i + <span class="number">1</span>) % n])&#125;;</span><br><span class="line">    pot b = &#123;ve[res] * ve[(res + <span class="number">1</span>) % n], <span class="built_in">abs</span>(ve[res] ^ ve[(res + <span class="number">1</span>) % n])&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((a ^ b) &gt; <span class="number">0</span>) res = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;极角序&quot;&gt;&lt;a href=&quot;#极角序&quot; class=&quot;headerlink&quot; title=&quot;极角序&quot;&gt;&lt;/a&gt;极角序&lt;/h1&gt;&lt;h2 id=&quot;atan2函数&quot;&gt;&lt;a href=&quot;#atan2函数&quot; class=&quot;headerlink&quot; title=&quot;atan2函数</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算几何" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程(2)-makefile</title>
    <link href="http://example.com/2023/08/10/makefile/"/>
    <id>http://example.com/2023/08/10/makefile/</id>
    <published>2023-08-09T16:00:00.000Z</published>
    <updated>2023-08-11T01:29:17.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个工程通常有许多源文件，这时代码编译就成了一个问题。<code>makefile</code> 就是为了解决这个问题，它可以决定文件的编译的先后，哪些文件需要重新编译等，从而实现“自动化编译”。有了<code>makefile</code> 整个工程只需要一个简单 <code>make</code> 命令就可以完成编译，方便了编译管理，节省编译时间等。</p><p>命名通常采用<code>Makefile</code> 或 <code>makefile</code> ，这两种文件名都可以被<code>make</code> 工具默认识别，建议使用大写的。也可以使用其他命名，比如<code>1.mk</code> ，但使用时要添加 <code>-f</code> 选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f 1.mk</span><br></pre></td></tr></table></figure><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>Makefile本质上是一个文本文件，其中包含一系列规则（rules），每个规则描述了如何生成一个或多个目标文件。每个规则由以下几部分组成：</p><ol><li>目标（Target）：规定了要生成的目标文件的名称。可以是可执行文件、目标文件、库文件等。</li><li>依赖（Dependencies）：列出了生成目标文件所需的依赖文件，即源代码文件或其他目标文件。</li><li>命令（Commands）：在目标文件的依赖文件更新时，Makefile中的命令将被执行，用于生成目标文件。命令必须以Tab开头。</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:main.o</span></span><br><span class="line">g++ main.o -o test</span><br></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>要生成一个目标需要先检查依赖条件，如果依赖不存在则寻找新规则生成依赖，如此递归进行直到所有依赖都存在后，再通过命令生成目标。</p><p>检查更新：如果目标文件比依赖文件的时间晚，则更新。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Makefile中的变量是一种用来存储和管理文本字符串的机制，它们可以帮助您使Makefile更加灵活和可维护。变量可以用于存储命令、文件名、编译选项等，使得在整个Makefile中可以通过引用变量来避免重复和冗余的代码。</p><p><strong>变量定义</strong> </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC = g++</span><br></pre></td></tr></table></figure><p>这里 <code>CC</code> 为变量名，<code>g++</code> 为变量值</p><p><strong>变量引用</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(变量名) 或者 $&#123;变量名&#125;</span><br></pre></td></tr></table></figure><p><strong>自动变量</strong> </p><p>Make工具还提供了一些特殊的自动变量，用于在规则中引用特定的值。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span> <span class="comment">#表示目标</span></span><br><span class="line"><span class="variable">$^</span> <span class="comment">#表示所有依赖</span></span><br><span class="line"><span class="variable">$&lt;</span> <span class="comment">#表示第一个依赖</span></span><br></pre></td></tr></table></figure><p>##模式规则</p><p>模式规则（Pattern Rule）是Makefile中的一种高级规则，它允许使用通配符来描述如何根据一组相似的依赖文件生成相应的目标文件。模式规则在构建具有类似结构的文件时非常有用，可以减少重复的规则定义。</p><p>比如有一组<code>cpp</code> 源文件，可以使用模式规则生成它们的 <code>.o</code> 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">g++ -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>##函数</p><p>Makefile中支持一些内置函数，这些函数可以用来操作文本字符串、路径、文件等，方便我们编写<code>makefile</code>语法规则。</p><p>比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VAL = <span class="variable">$(<span class="built_in">wildcard</span> ./*.cpp)</span> <span class="comment">#获取当前目录下所有.cpp文件</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(VAL)</span>)</span>  <span class="comment">#替换字符串中的模式</span></span><br><span class="line">DIR = <span class="variable">$(<span class="built_in">dir</span> src/main.cpp)</span> <span class="comment">#获取路径 src/main.cpp 中的目录部分</span></span><br></pre></td></tr></table></figure><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make   //运行 Makefile，默认会执行第一个目标。</span><br><span class="line">make target  // 执行指定目标，例如 make all 或 make clean。</span><br><span class="line">make -f filename  // 使用指定的 Makefile 文件，而不是默认的 Makefile 或 makefile。</span><br><span class="line">make clean  //清理生成的中间文件和目标文件。</span><br><span class="line">make all  // 构建项目的所有目标，通常是默认的目标。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;一个工程通常有许多源文件，这时代码编译就成了一个问题。&lt;code&gt;makefile&lt;/code&gt; 就是为了解决这个问题，它可以决定文件的编译</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="makefile" scheme="http://example.com/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程(1)-基础命令</title>
    <link href="http://example.com/2023/08/09/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0(1)/"/>
    <id>http://example.com/2023/08/09/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0(1)/</id>
    <published>2023-08-08T16:00:00.000Z</published>
    <updated>2023-08-11T04:53:47.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Tab</strong> </p><ul><li>补齐命令</li><li>补齐路径</li><li>显示当前目录下的所有目录</li></ul><p><strong>以下&#x2F;&#x2F;代表注释</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear  // 清屏  或者按 ctrl + l</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + c   // 中断进程</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + u/k   // 删除光标前/后所有内容</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>     // 切换到当前用户的主目录</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">cd</span> -   // 切换到上一个进入的目录</span><br><span class="line"><span class="built_in">cd</span> /    // 切换到根目录</span><br><span class="line"><span class="built_in">cd</span> ..   // 切换到上一级目录</span><br><span class="line"><span class="built_in">cd</span> ../..    // 切换到上上一级目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>   // 显示当前工作路径</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>   // 列出当前目录下的文件和子目录</span><br><span class="line"><span class="built_in">ls</span> -a  // 列出所有当前目录下的文件和子目录，包括隐藏的</span><br></pre></td></tr></table></figure><p><strong>创建目录</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir_name ... // 创建单个或多个目录</span><br><span class="line"><span class="built_in">mkdir</span> -p /path/to/a/b  // 创建嵌套目录</span><br><span class="line"><span class="built_in">mkdir</span> dir_name&#123;1..100&#125; // 创建目录 dir_name1 ... dir_name100</span><br><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;a    b&quot;</span> // 目录名含有特殊字符时可以用双引号或者转义</span><br></pre></td></tr></table></figure><p><strong>删除目录</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> dir_name </span><br><span class="line">...</span><br><span class="line"><span class="built_in">rm</span> -d dir_name // 删除一个空目录</span><br><span class="line"><span class="built_in">rm</span> -r dir_name // 可以删空或非空目录</span><br></pre></td></tr></table></figure><p><strong>文件类型分类</strong> </p><p>白色：普通文件</p><p>绿色：可执行文件</p><p>红色：压缩文件</p><p>蓝色：目录</p><p>青色：链接文件</p><p>黄色：设备文件</p><p>灰色：其他文件</p><p><strong>通配符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;*&#x27;</span>   // 匹配任意长度的字符</span><br><span class="line"><span class="string">&#x27;?&#x27;</span>   // 匹配任意单个字符</span><br><span class="line"><span class="string">&#x27;[]&#x27;</span>  // 匹配方括号内指定的任意一个字符</span><br><span class="line"><span class="string">&#x27;[-]&#x27;</span> // 匹配方括号内指定范围的字符</span><br><span class="line"><span class="string">&#x27;[^]&#x27;</span> // 匹配方括号内未指定的任意一个字符</span><br><span class="line"><span class="string">&#x27;~&#x27;</span>   // 代表当前用户的主目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 配合 `<span class="built_in">ls</span>` 使用</span><br><span class="line"><span class="built_in">ls</span> pro*  // 查找以pro开头的文件</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 文件相关操作，不能用于目录</span><br><span class="line"><span class="built_in">touch</span> file_name1 file_name2  // 文件存在更新文件访问和时间戳，不存在则创建</span><br><span class="line"><span class="built_in">touch</span> -c file_name      // 文件不存在则创建，存在不会更新已有文件和时间戳</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> file_name1 [...] path   // 拷贝文件到目录，已有同名文件会覆盖</span><br><span class="line"><span class="built_in">cp</span> -i file_name1 [...] path  // 会询问是否覆盖</span><br><span class="line"><span class="built_in">cp</span> -r dir1 dir2    // 拷贝目录到另一目录，默认覆盖</span><br><span class="line"><span class="built_in">cp</span> -rv dir1 dir2   // 显示拷贝进度</span><br><span class="line"><span class="built_in">cp</span> -r -i dir1 dir2  // 询问</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file file2 // 重命名为file2</span><br><span class="line"><span class="built_in">mv</span> file <span class="built_in">dir</span>  // 将file移动到<span class="built_in">dir</span>目录下</span><br><span class="line"><span class="built_in">mv</span> dir1 dir2 // 将dir1目录移动到dir2目录下</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 1.txt  // 将文件内容一次性输出到终端</span><br><span class="line"><span class="built_in">cat</span> -n 1.txt // 按行编号输出，空行也会编号</span><br><span class="line"><span class="built_in">cat</span> -b 1.txt // 按编号输出，编号略过空行</span><br><span class="line"><span class="built_in">cat</span> -A 1.txt // 显示所有信息</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 1.txt // 将内容分页显示到终端</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh 1.txt // 查看文件大小</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h   // 检测文件系统的磁盘空间占用和空余情况</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find path -name <span class="string">&quot;*.txt&quot;</span> // 查找path路径下所有txt文件</span><br><span class="line">find ./ -size +1k/M -size -10k/M // 查找当前目录下大于1k/M小于10k的文件</span><br><span class="line">find ./ -<span class="built_in">type</span> b/c/d/f/s/i/p  // 按文件类型查找</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 对文本进行模式查找，匹配则打印包含模式的所有行</span><br><span class="line">grep <span class="string">&quot;std&quot;</span> path/file_name  // 查找文件中包含std的所有行</span><br><span class="line">grep -n <span class="string">&quot;std&quot;</span> path/file_name  // 选项 -n 显示出现的行号</span><br><span class="line">// -v 所有不包含的行</span><br><span class="line">// -r 在当前目录下所有文件中查询</span><br><span class="line">// -i 忽略大小写</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 管道  一个命令的输出可以作为另一个命令的输入</span><br><span class="line"><span class="built_in">cat</span> 1.cpp | grep <span class="string">&quot;std&quot;</span>  // 从<span class="built_in">cat</span> 1.cpp里查找</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// tar [选项] 打包文件名 文件</span><br><span class="line">tar -cvf test.tar 1.txt 2.txt 3.txt  // 创建归档</span><br><span class="line">tar -xvf test.tar   // 接触归档</span><br><span class="line">tar -tvf test.tar  // 列出归档文件中的内容</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// gzip [-d/r] 要压缩的文件，只能压缩文件，对于目录要先打包成文件</span><br><span class="line">gzip 1.txt  // 不保留原文件的压缩</span><br><span class="line">gzip -d 1.gz // 解压</span><br><span class="line">gzip -r <span class="built_in">dir</span>  // 对目录下所有文件进行压缩</span><br><span class="line">tar -czvf dir.tar.gz <span class="built_in">dir</span>  // 打包并压缩目录</span><br><span class="line">tar -xzvf dir.tar.gz  // 解压</span><br><span class="line">tar -xzvf dir.tar.gz -C path  // 解压到path目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u/o/g/a+/-/=r/w/x file   // 权限设定</span><br><span class="line"><span class="built_in">chmod</span> u+w,g=r,a+r file</span><br><span class="line">// 数字法</span><br><span class="line"><span class="built_in">chmod</span> 751 file  // 文件所有者 同组用户 其他用户</span><br><span class="line"><span class="built_in">chmod</span> -R 777 <span class="built_in">dir</span>  // 递归更改该目录下所有文件的用户权限</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> uer_name file // 修改文件所属者</span><br><span class="line"><span class="built_in">chown</span> :group_name file // 修改文件所属组，两个可以一起设定</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install package_name // 安装软件</span><br><span class="line">sudo apt remove package_name  // 删除软件</span><br><span class="line">sudo apt update  // 更新软件包列表</span><br><span class="line">sudo apt upgrade // 更新已安装的软件包</span><br><span class="line">apt-cache search search_term // 搜索软件包</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 重定向，将输出写入文件中</span><br><span class="line"><span class="built_in">ls</span> &gt; 1.txt // 标准输出，覆盖原有内容</span><br><span class="line"><span class="built_in">ls</span> &gt;&gt; 1.txt // 追加到原有内容之后</span><br><span class="line">tttt 2&gt; 1.txt // 适用错误信息输出</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree [path] // 显示目录树</span><br><span class="line">tree -L number // 最多显示几层</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> a.txt a_link // 创建一个文件的硬链接，和原文件指向同一个内存地址</span><br><span class="line"><span class="built_in">ln</span> -s a.txt [path] a_link // 创建符号链接，存储的是指向源文件的路径</span><br></pre></td></tr></table></figure><p><strong>vim使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 命令模式下</span><br><span class="line">[num]yy // 复制从当前行开始的num行</span><br><span class="line">p // 粘贴</span><br><span class="line">[num]x // 删除光标后的num个字符</span><br><span class="line">[num]X // 删除光标前的num个字符</span><br><span class="line">D // 删除当前位置到行尾的所有字符</span><br><span class="line">[num]<span class="built_in">dd</span> // 剪贴当前行开始的num行</span><br><span class="line">dG  // 删除光标所在行到文本尾的所有字符</span><br><span class="line">dw  // 删除光标开始位置的单词，包含光标所在字符</span><br><span class="line">d0  // 删除光标开始到行首所有字符</span><br><span class="line">dgg // 删除光标所在行到文本首的所有字符</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u  // 撤销</span><br><span class="line">[num].  // 执行上一次操作 num 次</span><br><span class="line">ctrl + r // 反撤销</span><br><span class="line">ZZ  // 保存退出</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/string  // 从当前光标位置向下查找字符串 n 光标跳到下一个位置， N 上一个位置</span><br><span class="line">?string  // 向下</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r // 替换字符</span><br><span class="line">R // 进入替换模式</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// :进入末行模式，执行后自动回到命令模式</span><br><span class="line">:wq // 保存退出</span><br><span class="line">：x // 保存退出</span><br><span class="line">:w file // 保存到指定文件</span><br><span class="line">:q  // 文件未修改可以退出</span><br><span class="line">:q! // 退出，不保存</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:[st, ed]s/string1/string2/  // 将st到ed行/光标所在行第一次string1改为string2</span><br><span class="line">:[st, ed]s/string1/string2/g // string1全改为string2</span><br><span class="line">:%s/string1/string2/g  // 将文本内所有替换</span><br><span class="line">:%s/string1/string2/gc  // 同上，但每次替换需要确认</span><br><span class="line">:1,<span class="variable">$s</span>/string1/string2/g  // 文本内所有替换</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:sp [file_name] // 水平分屏,不填最后参数和自己分屏，ctrl+w切换窗口</span><br><span class="line">:vsp [file_name] // 垂直分屏，同上</span><br><span class="line">:wall/:wqall/:qall // 保存/保存退出/退出所有窗口</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -O a.cpp b.cpp // 垂直分屏</span><br><span class="line">vim -o a.cpp b.cpp // 水平分屏</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// vim命令模式下使用</span><br><span class="line">:!man <span class="built_in">ls</span>  // 查看手册</span><br><span class="line">:r !<span class="built_in">ls</span> -l // 将<span class="built_in">ls</span> -l执行结果写入到文件中</span><br><span class="line">:r path // 将文件内容写入到当前文件中</span><br><span class="line">:w path // 将当前文件写入到指定文件中</span><br><span class="line">:w! path // 强制</span><br><span class="line">:[st, ed]s<span class="comment">#^#//#g  // 行首加注释</span></span><br><span class="line">:[st, ed]s<span class="comment">#//##g   // 去掉行首注释</span></span><br></pre></td></tr></table></figure><p><strong>cpp编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g++ -E a.cpp -o a.i  // 预处理</span><br><span class="line">g++ -S a.i -o a.s   // 编译</span><br><span class="line">g++ -c a.s -o a.o   // 汇编</span><br><span class="line">g++ a.o -o a.exe    // 链接</span><br><span class="line">g++ -o a a.cpp   // 包含上述四步</span><br><span class="line">g++ a.cpp -o a   // 同上</span><br><span class="line">g++ -Wall  // 显示所有警告</span><br><span class="line">g++ -Wall -Werror a.cpp // 将所有警告当成错误处理</span><br><span class="line">g++ a.cpp -o a -DTAG // 定义宏TAG编译</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-g 包含调试信息</span><br><span class="line">g++ -g -o a a.cpp</span><br><span class="line">-O1/2/3  代码优化</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Tab&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补齐命令&lt;/li&gt;
&lt;li&gt;补齐路径&lt;/li&gt;
&lt;li&gt;显示当前目录下的所有目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;以下&amp;#x2F;&amp;#x2F;代表注释&lt;/strong&gt;&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LCA</title>
    <link href="http://example.com/2023/05/06/LCA/"/>
    <id>http://example.com/2023/05/06/LCA/</id>
    <published>2023-05-05T16:00:00.000Z</published>
    <updated>2023-05-07T15:35:20.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$\qquad$ LCA (Least Common Ancestors)，即最近公共祖先，这种描述是基于树形结构的。对于 $u, v$ 两点它们的最近公共祖先就是从各自到树根的路径上的第一个共同点，或者说是这两个点的所有公共祖先里离根最远的那个点。</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法:"></a>倍增算法:</h3><p>$\qquad$ 我们定义 $fa[i][j]$ 的含义为点 $i$ 往上走 $2^j$ 步的祖先是谁，可以通过递推求出，预处理复杂度 $O(nlogn)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dep</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fa</span>(n + <span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">22</span>));</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : g[u]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            fa[v][<span class="number">0</span>] = u;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">            fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\qquad$ 有了 $fa$ 数组和点在树中的深度 $dep$ 后，就可以查询两点的 LCA 了，过程如下：</p><p>$\qquad$ 我们先将深度大的点往上跳至两点在同一深度，过程类似二进制拼凑，不妨设深度大的那个点为 $u$ ，还需走 $w$ 步到达同一深度，观察 $w$ 的二进制，要走的步数就是 $w$ 的二进制为 $1$ 的那些位的权值和，从高位往低位循环，设当前位为 $j$，如果 $dep[fa[u][j]] &lt;&#x3D; dep[v]$，因为我们所走的步数的二进制前缀与 $w$ 相同，条件成立说明该位为 $1$ ，就往上跳，最终就可以凑出 $w$ 步。然后将两点同时往上跳，过程与上面类似，判断条件变成如果 $fa[u][j] !&#x3D; fa[v][j]$ 那就往上跳。</p><p>$\qquad$ 很明显查询的复杂度是 $O(logn)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; lca = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v) </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">       <span class="comment">// 跳至同一深度</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">           <span class="keyword">if</span> (dep[fa[u][i]] &gt;= dep[v]) </span><br><span class="line">               v = fa[u][i];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">           <span class="keyword">if</span> (fa[u][i] != fa[v][i]) </span><br><span class="line">u = fa[u][i], v = fa[v][i];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 再往上走一步才是最近公共祖先</span></span><br><span class="line">       <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>$\qquad$ LCA 是满足结合律的，即 $LCA(a, b, c) &#x3D; LCA(LCA(a, b), c)$ ，求多个点的 LCA 就解决了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;$&#92;qquad$ LCA (Least Common Ancestors)，即最近公共祖先，这种描述是基于树形结构的。对于 $u, v$ 两</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>无向图三元环计数</title>
    <link href="http://example.com/2023/05/05/%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/"/>
    <id>http://example.com/2023/05/05/%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/</id>
    <published>2023-05-04T16:00:00.000Z</published>
    <updated>2023-08-09T09:40:42.394Z</updated>
    
    <content type="html"><![CDATA[<p>$\qquad$ 如题，该算法解决的问题就是计算一个无向图中有多少个三元环，采用的思想是根号分治。</p><p>$\qquad$ 考虑给所有边赋予一个方向，具体的，对于原图的每条边将度小的点指向度大的点，度相等的则将编号小的指向编号大的点来建一个新的有向图。由此得到的图是有向无环的。</p><p>$\qquad$ 证明：从一个点出发开始走，途径的点的度一定是非递减的，如果路径上点度都相等，点的编号一定是递增的，则其一定不会指向到达该点的路径上的点，所以新图一定是无环的。</p><p>$\qquad$ 如何计数？原图的三元环在新图中对应为满足 $u \rightarrow v, u \rightarrow w, v \rightarrow w$ 的三个点 $u, v, w$。考虑枚举所有边，这对应第一个条件，再枚举 $u$ 的所有出边，这对应第二个条件，是否满足第三个条件还需要再枚举 $v$ 的所有出边判断，在枚$u$ 的出边时给所有点打上一个时间戳，这样就可以在枚举 $v$  的时候 $O(1)$ 判断是否满足第三个条件。</p><p>复杂度证明：</p><p>$\qquad$ 由上述可得复杂度为 $\sum_{i &#x3D; 1}^m(d_u + d_v)$ , 其中 $d_i$ 表示点 $i$ 在新图中的度，通过分类讨论可以证明 $d_i$ 最大不超过 $\sqrt m$ 。设在原图中点 $i$ 的度数为 $deg_i$ ，当 $deg_u &lt;&#x3D; \sqrt m$ ，自然满足 $d_u &lt;&#x3D; \sqrt m$ 。当 $deg_u &gt; \sqrt m$ 时，由于我们建新图的方式，它在新图中的终点 $v$ 必定满足 $deg_v &gt;&#x3D; deg_u$ ，因为总边数为 $m$ ，则 $v$ 的数量不超过 $\frac{m}{\sqrt m}$ 个，所以复杂度就是 $m \sqrt m$。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> cas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    g = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (n + <span class="number">10</span>);</span><br><span class="line">    set&lt;pii&gt; ens;</span><br><span class="line">    vector&lt;pii&gt; edg;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (u == v || ens.<span class="built_in">count</span>(&#123;u, v&#125;)) <span class="keyword">continue</span>;</span><br><span class="line">        edg.<span class="built_in">pb</span>(&#123;u, v&#125;);</span><br><span class="line">        ens.<span class="built_in">insert</span>(&#123;u, v&#125;);</span><br><span class="line">        d[u]++, d[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edg.<span class="built_in">size</span>(); i++) </span><br><span class="line">        <span class="keyword">if</span> (d[edg[i].fi] &lt;= d[edg[i].se]) g[edg[i].fi].<span class="built_in">pb</span>(edg[i].se);</span><br><span class="line">        <span class="keyword">else</span> g[edg[i].se].<span class="built_in">pb</span>(edg[i].fi);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edg.<span class="built_in">size</span>(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = edg[i].fi, v = edg[i].se;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : g[u]) vis[w] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : g[v]) </span><br><span class="line">            <span class="keyword">if</span> (vis[w] == u) res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$&#92;qquad$ 如题，该算法解决的问题就是计算一个无向图中有多少个三元环，采用的思想是根号分治。&lt;/p&gt;
&lt;p&gt;$&#92;qquad$ 考虑给所有边赋予一个方向，具体的，对于原图的每条边将度小的点指向度大的点，度相等的则将编号小的指向编号大的点来建一个新的有向图。由此得到的图是</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
