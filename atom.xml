<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Celopsの一片净土</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-12T03:57:52.802Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Celops</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ACM退役小作文</title>
    <link href="http://example.com/2023/05/11/ACM%E9%80%80%E5%BD%B9%E5%B0%8F%E4%BD%9C%E6%96%87/"/>
    <id>http://example.com/2023/05/11/ACM%E9%80%80%E5%BD%B9%E5%B0%8F%E4%BD%9C%E6%96%87/</id>
    <published>2023-05-10T16:00:00.000Z</published>
    <updated>2023-05-12T03:57:52.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>$\qquad$ 若干年过去了，打开自己的社交软件，竟找不出一点生活、过往和记录。过去那些深刻的不深刻的，重要的不重要的，都没有留下任何痕迹。于是本文应运而生，给那些经历一个被保存的机会，也算是给一些事画上句号。</p><h1 id="主线"><a href="#主线" class="headerlink" title="主线"></a>主线</h1><h2 id="首年"><a href="#首年" class="headerlink" title="首年"></a>首年</h2><p>$\qquad$ 成为 $acmer$ 的过程还是有点是坎坷的。入学前了解到很多人想进 $acm$ ，我也就趋之若鹜，真正下定决心要进集训队是后来在宣讲会上看到历届 $acm$ 集训队学长的诱人的薪酬。但理想总与现实相悖，上学期各种比赛始终没有拿到一个可观的成绩，也没有被选入实验室，现在同级的 $acmer$ 除了我应该都是第一批入选的。那段时间真的很痛苦，也陷入了深深地自我怀疑，明明投入了很多时间和精力却没有任何成效，开始思考自己是否真的适合打 $acm$ 。或许是命运对我的悲悯，新生赛因为疫情推迟到了下学期，也侥幸入选寒假集训营，给了我缓冲的机会，决定收起迷茫孤注一掷，再不出成绩就准备放弃了。寒假在同级的交谈中意识到了自己学习路线的错误，因为学算法起步的很晚，寒假里不敢有一丝松懈。那段时间依旧是焦虑，感觉醒着的几乎时间都在学了，却还是没有完整完成过学长的训练安排。这期间也组织了几次比赛，只有一场侥幸拿了个还看的过去的名次，以为就要到此为止了。到了下学期，意外的是两次周赛排名都挺靠前，新生赛也拿了 $rk3$ ，进了实验室，才慢慢地有了信心。后面就是和 $scz$ ，$hza$ 组上了队，开始组队训练准备新生赛和 $ccpc$ 省赛。记得当时的小群里经常”加训”，”狠狠地训”，”拼搏xx天我要当最佳新生队！”之类的，斗志都很高。后来这种能感受到彼此都在拼尽全力的安心感也一直激励和支撑着我。可惜的是不久因为疫情开始封校，然后提前放假，$21$级也就没有了校赛，省赛也推迟到了十月。后面就是暑假集训了，因为不能留校了，学长怕效果不如线下就整了个腾讯会议开摄像头的方式集训。</p><h2 id="低谷"><a href="#低谷" class="headerlink" title="低谷"></a>低谷</h2><p>$\qquad$ 暑假时有一场$cf$直接掉了$80$分，因为这次失误和自己对分数的过分看重，导致后两场敲代码的时候手都在抖，心态也没控制好，直接连掉三场。这又让我开始自我怀疑了，加之牛客多校和杭电多校的组队赛——据说这比赛是对标区域赛难度出的（现在看来是比区域赛难的），打到后面几乎都在坐牢，每次只写出来一两题，让我重新审视了算竞的难度。当时是很受打击的，因为看不到什么希望，已经有了想放弃$acm$的念头了，但是看着我两个队友的状态，最后还是决定冲一把，人生是需要冒险的。虽然还在坚持，但心态已经发生了变化，之后的压力一直很大。</p><h2 id="次年兼末年"><a href="#次年兼末年" class="headerlink" title="次年兼末年"></a>次年兼末年</h2><p>$\qquad$ 大二开学搬去了科学，我两个队友也都转到了我的专业，我们的时间更同步了。十一国庆的$ccpc$省赛我们队拿了金，可以说是首战告捷。在五六号的时候突然封寝了，之后在宿舍的学习效率一直很不如意，又临近区域赛了。我的队友$hza$为求效率就开始了黑白颠倒的作息，我也跟着尝试，当时就是吃了八点送的早餐就开始睡，下午六七点醒来吃晚饭，晚上再把午饭热热吃了再一战到天亮，吃完早饭倒头就睡。持续了几天开始胸闷头晕牙痛各种身体不适，$hza$说那是猝死前兆又自己搜了搜真的被吓到了，早上闭上眼准备睡的时候总是怕自己一觉醒不来了，于是就恢复正常作息了。封寝生活熬了一个多月，终于迎来了我们的第一场区域赛$ccpc$广州站，可惜的是公费旅游的梦幻灭了，只能线上打。记得那天刚好是学习第一波放人，当我醒来时我室友都已经在回家路上了。</p><h3 id="广州站"><a href="#广州站" class="headerlink" title="广州站"></a>广州站</h3><p>$\qquad$ 这场开局非常顺利，光速签到没有一发罚时，那时候都在银首了，我们都很激动，如果能继续出题应该是有银的。不过最后却是坐了四小时牢，赛后发现再出一题真能银的。第一年就想拿银终究是幻想，这场能拿铜牌完全靠手速和运气。</p><p>$\qquad$ 后面学校人走的差不多，我们白天直接搬到一个宿舍里一块训练，那段时间是真的让我们在生活上完全融入了，也是我们队的巅峰状态，默契和配合已经打出来了。因为第一场拿了铜，老师又给我们争取了个杭州站的名额。广州拿牌全靠运气，又听说杭州队伍数多强队也多，强度直接拉满了，那肯定是要加训。$scz$作为队长同时也是我们$21$级领队，对自己要求很严格，亦擅长压力队友。经常就是<br>$scz$：明天九点起来训练。<br>我：九点？<br>$scz$百般颜艺之惊讶态：九点还不行？<br>看我有点不情愿<br>$scz$：明天九点我就来，看你起不起就完了，别给我锁门听见没有。<br>然后扬长而去，接着第二天我就在$scz$纤弱的手掌与床栏的撞击声中醒来了，他扔下一句”赶紧给我起来”转而就再去折磨$hza$。那段时间$scz$的某些潜在属性也被开发出来了，动不动就跟人狗叫，亦不吝惜展现自己在颜艺上的绝佳天赋（那表情真是谁看了都想来一拳）。</p><p>$\qquad$ 虽然训练很累，但也是真的快乐。每天形影不离，一起训练一起买饭一起撸猫各种事情。</p><p>$\qquad$ 后来那六只猫这学期只再遇到过一只，实属孽缘。</p><p>🐱:一个动作让人类为我花两千大洋，吊不吊？</p><p><img src="https://raw.githubusercontent.com/Celops-H/image/main/PicGo/202305120027833.jpg"></p><blockquote><p>跟它玩的时候不小心被抓出血了，怕死就去打了疫苗，前后一共花了快两千，你没有猫德啊。</p></blockquote><p>$\qquad$ 截至目前肇事猫依旧逍遥法外。</p><p><img src="https://raw.githubusercontent.com/Celops-H/image/main/PicGo/202305112056118.jpg"></p><blockquote><p>附凶手</p></blockquote><p>$\qquad$ 接回正题，杭州那天$hza$被认定为密接要被拉去隔离了，又突然被告知要求被搬去x号楼(最后又没搬)，导员来让我们收拾东西，最后答应我们打完再搬，所幸比赛没有被影响。</p><h3 id="杭州站"><a href="#杭州站" class="headerlink" title="杭州站"></a>杭州站</h3><p>$\qquad$ 封榜后连过两题，剩下半小时也开不了题了，看榜发现稳铜了，有人也来通知$hza$去酒店的车要开了，索性直接下班。我们一直在说杭州站很凶险，却是打的最好的一场，可能我们真的有了铜牌水平了。南京站的时间是$12.19$比较晚，$scz$说那时候应该很多人回家了应该有不少队都是单挑，而且那时候也是期末说不定有人要考试打不了，再加之南京队伍远没有杭州多，就对南京寄予了厚望，渴望能到这有个好结果功成身退，随即立下$flag$：如果南京能拿银当晚我就坐那开始写退役总结。</p><h3 id="南京站"><a href="#南京站" class="headerlink" title="南京站"></a>南京站</h3><p>$\qquad$ 最寄予希望的一场却成了最应该反思的一场，总结就是最后我和$scz$两题都没有过，看榜时心灰意冷感觉要打铁了。回去看滚榜发现还是有铜的又开心又失落的。</p><p>$\qquad$ 到这里这赛季是结束了。惯例寒假还是训练。</p><h1 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h1><p>$\qquad$ 虽然铜没什么含金量，但仅以第一年参赛的成绩来说我们队是历届最好的了，过去我们学校只有一队第一年拿了个铜。如果这个状态保持下去下年银肯定是有的。可是开学后$hza$几乎不来实验室了，那次作为出题人去东风参加天梯赛颁奖会回来的路上也尝试沟通但无果。过了忘了多久我们约他出来聊了很多很多，最后也都说明白了他确实是不想打了，已经没有当初的喜欢了，觉得有比$acm$更好的选择，为了不可妥协的前途，人总是要分开的。虽然还在和$scz$保持训练，但是心里已经没那么坚毅了，有点迷茫了，经常学不进去跑到二楼阳台或者篮球场那里发呆。我跟$scz$讨论过物色新队友的事，但是没有合适的人选。同级$zhy$他们队伍$lzc$也不想打了早就在学技术了。我提议我退役让$scz$和剩下那两个人$zhy$和$zyb$组，最后还是被劝下来。我是那种路没铺平就无法全力往前走的人，找队友这件事不解决我实在是无法静下心训练。那时候学不进去我一直在$scz$耳边”怎么办怎么办”，然后就被骂了：“那你说怎么办，就这样不学了？巴拉巴拉…”，最后说让我放心，就算是两个人下赛季他也给我保证拿银。我很信任他，他也真的是一个很可靠也是我一直在依赖的人。后面老师说有个单挑能拿银的$oier$专升本要考咱们学校到时候和我们组队。单挑拿银这学习能力，我在心里已经默认他已经考上了，也就沉下心学了段时间。</p><p>$\qquad$ 四月下旬，专升本成绩公布了，没几天被告知他没有考上，看着$scz$发的信息，有什么想说的却又说不出来。本来在写一道题思路已经理清就差码代码了，但是从下午到晚上那题始终都没有过，完全无法集中，动不动就发呆，失眠也加重了，那两天都是三四点才睡着。</p><h1 id="决定与结束"><a href="#决定与结束" class="headerlink" title="决定与结束"></a>决定与结束</h1><p>$\qquad$ 虽然有$scz$的保证，但我还是无法接受没有稳定可靠的队友，每次比赛都在凑人对心态也是折磨。这些的波折已然耗尽了我的精力，我也清楚地感受到自己身上已经没有了当初的决心、勇气和毅力了。$zhy$，$zyb$他们和我俩四个人一直被分在两个残缺的队伍里也不是办法，而且，他们和我是不一样的，他们是有热爱在里面的，远比我要纯粹，倒不如成全他们，肯定比和我一起能走的更远。正式决定退役了，最后也是说服了$scz$。</p><h1 id="之后的事"><a href="#之后的事" class="headerlink" title="之后的事"></a>之后的事</h1><p>$\qquad$ 然后就摆了好几天，狠狠地打了一番云顶。马上要五一了，就跟室友商量一起出游刚好调整调整，结果到放假了谁都没有提前做规划，然后就穷游郑州了。后两天有了搭博客的想法，$5.4$绑定完域名终于落成，如果以后时间充裕的话会整理整理之前学过的东西放在这里，也准备学点技术了可能会更一些技术文。</p><h1 id="一些感慨"><a href="#一些感慨" class="headerlink" title="一些感慨"></a>一些感慨</h1><p>$\qquad$ 曾经还是设想过自己写退役总结的场景的，比如如果那天南京成功拿银功成身退，或者是打完年末赛季的时候已然大三惯例上个小作文，怎么也没料到会是现在这样，我还是太低估生活的无常了。</p><p>$\qquad$ 退役之后就把$ccpc final$的名额让给了$scz$现在的队友，他们也开始一起打比赛磨合了。那天回实验室还没进门就看到$scz$和他现在的队友在$vp$比赛，因为我的位置和$scz$是挨着的，他们自然就坐到了我的位置上，刚好有一种取代我的意蕴，不知道怎么了心里就是有点生气扭头就要回宿舍，又想想完全是莫名其妙，是自己太敏感了，不过都是我无聊的嫉妒罢了，我又回去把我的东西搬到了个安静点的位置。还记得$scz$和我说过，他是真的想冲一冲，拿个$zzuli$首金然后名留青史，如果那个$oier$的能来真的要冲一波金牌了，当时听的我也热血沸腾，但现在这些都不重要了，那已经是不属于我的梦想了。虽然我们三个的关系一如往常，心里却还是有种某些东西已经破碎了的感觉。5.7的省赛是我最后一次和$scz$打比赛了，却因为被卡常错失了金导致成绩还不如去年，失败和遗憾贯穿人生始终吧。准备了近两年没有拿区域银还是很不甘心的，还有当初向往的公费旅游至今也没有实现过。疫情不在了，以后都是线下了，我也没有机会参与了。学不会舍弃的人，什么都改变不了。无论是遗憾，不舍还是不甘，都要懂得割舍坦荡往前走了，虽然还没想好以后干什么，但人生就是在迷茫和苏醒中重复吧，终归会有答案的。</p><p>$\qquad$ 如果和我谈收获，我真的吐不出几个字来。没什么可以拿的出手的成绩，除了算法什么都没学，最大的收获可能就是对自己的磨练和从这个圈子接触到了各种优秀的人吧。$acm$绝不是最有性价比的选择，它是一种高投入低回报甚至没有回报的东西，能证明成果的就是区域赛金银了吧，其他多数比赛的奖感觉只是德育分罢了。它太残酷难度也太大了，$xcpc$区域赛金牌区鲜有双非，对于很多学校的$acmer$来说银已经是终点了，最近的就业形式银牌的含金量也被动摇了，这条路真是越走越难了。</p><p>$\qquad$ 让我感到挫败的是，不仅$acm$没做出成绩，没能在学业和其他事上做好平衡，也让我错过和主动放弃了很多东西。我一直清楚地知道自己并不喜欢$acm$，这两年压抑远比欢乐要多，却还是出于对前程的考虑逼迫着自己坚持，赋予了它极大的权重，期望全力以赴最后能有万一之得。每天匆忙的在校园里穿行，追逐着自己都不能切实感受到的东西，不断地给自己施压并焦虑着，失眠已经忘了持续了多久，每次都需要躺一到两小时才能入睡，心里有事的时候三四个小时也有。一周只上两三节逃不掉课其他几乎都在泡实验室，睡眠不是太糟的情况下早上九点左右到实验室，晚上九十点才回宿舍，一年多里也没有允许自己回宿舍午睡过。以为把自己贯彻的足够冷漠才能做到真正的果决，真正的心无旁骛，做什么都在考虑时间成本，考虑怎样才能效率最大化。到最后呢，学也没学好，玩也没玩好，别的很多事情也都没有精力去应对没有处理好，真的失去了好多好多。还记得以前对大学的幻想是偶尔泡泡图书馆，平时能和室友开黑打打游戏，把烟戒了，打打球，去健身房练练块，而如今的生活却早已远远背离了当初的愿景。大学不是只有学习这一件事的，我错把它当成了第一要义，对前途太过看重，以为只有倾尽所有时间去提升自己才是对未来的慷慨，却从未理会过灵魂深处痛苦的呼声，最后终于在那些有意无意间的波澜起伏中被压垮，体会到了精神和肉体上的前所未有的疲惫。内耗是没有尽头的，人生的终极课程永远是学会好好与自己相处，以后就不那么压力自己了，适当降低期望和要求，把更多的时间分给生活，要去尝试下那些曾经想触及却又收回手的事物了。</p><h1 id="5-10"><a href="#5-10" class="headerlink" title="5.10"></a>5.10</h1><p>$\qquad$ 这篇文章在$5.7$ $ccpc$省赛打完就开始着手写了，到这天因为图片的问题一直没有发出来。本以为$ccpc$省赛的结束也是我$acm$生涯的落幕，结果$lzc$又找老师要到个$icpc$省赛的名额，$lzc$，我，$hza$三个退役的又组了一队，全当是去旅游观光了，队名初步拟定就叫“最后一舞”。</p><p>$\qquad$ 最近开始去上课了，单纯是怀念以前坐在教室的那种感觉，体验体验氛围。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;导言&quot;&gt;&lt;a href=&quot;#导言&quot; class=&quot;headerlink&quot; title=&quot;导言&quot;&gt;&lt;/a&gt;导言&lt;/h1&gt;&lt;p&gt;$&#92;qquad$ 若干年过去了，打开自己的社交软件，竟找不出一点生活、过往和记录。过去那些深刻的不深刻的，重要的不重要的，都没有留下任何痕迹</summary>
      
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LCA</title>
    <link href="http://example.com/2023/05/06/LCA/"/>
    <id>http://example.com/2023/05/06/LCA/</id>
    <published>2023-05-05T16:00:00.000Z</published>
    <updated>2023-05-07T15:35:20.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$\qquad$ LCA (Least Common Ancestors)，即最近公共祖先，这种描述是基于树形结构的。对于 $u, v$ 两点它们的最近公共祖先就是从各自到树根的路径上的第一个共同点，或者说是这两个点的所有公共祖先里离根最远的那个点。</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法:"></a>倍增算法:</h3><p>$\qquad$ 我们定义 $fa[i][j]$ 的含义为点 $i$ 往上走 $2^j$ 步的祖先是谁，可以通过递推求出，预处理复杂度 $O(nlogn)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dep</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fa</span>(n + <span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">22</span>));</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : g[u]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            fa[v][<span class="number">0</span>] = u;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">            fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\qquad$ 有了 $fa$ 数组和点在树中的深度 $dep$ 后，就可以查询两点的 LCA 了，过程如下：</p><p>$\qquad$ 我们先将深度大的点往上跳至两点在同一深度，过程类似二进制拼凑，不妨设深度大的那个点为 $u$ ，还需走 $w$ 步到达同一深度，观察 $w$ 的二进制，要走的步数就是 $w$ 的二进制为 $1$ 的那些位的权值和，从高位往低位循环，设当前位为 $j$，如果 $dep[fa[u][j]] &lt;&#x3D; dep[v]$，因为我们所走的步数的二进制前缀与 $w$ 相同，条件成立说明该位为 $1$ ，就往上跳，最终就可以凑出 $w$ 步。然后将两点同时往上跳，过程与上面类似，判断条件变成如果 $fa[u][j] !&#x3D; fa[v][j]$ 那就往上跳。</p><p>$\qquad$ 很明显查询的复杂度是 $O(logn)$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; lca = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v) </span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">       <span class="comment">// 跳至同一深度</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">           <span class="keyword">if</span> (dep[fa[u][i]] &gt;= dep[v]) </span><br><span class="line">               v = fa[u][i];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">           <span class="keyword">if</span> (fa[u][i] != fa[v][i]) </span><br><span class="line">u = fa[u][i], v = fa[v][i];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 再往上走一步才是最近公共祖先</span></span><br><span class="line">       <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>$\qquad$ LCA 是满足结合律的，即 $LCA(a, b, c) &#x3D; LCA(LCA(a, b), c)$ ，求多个点的 LCA 就解决了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;$&#92;qquad$ LCA (Least Common Ancestors)，即最近公共祖先，这种描述是基于树形结构的。对于 $u, v$ 两</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>无向图三元环计数</title>
    <link href="http://example.com/2023/05/05/%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/"/>
    <id>http://example.com/2023/05/05/%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/</id>
    <published>2023-05-04T16:00:00.000Z</published>
    <updated>2023-05-06T08:12:33.373Z</updated>
    
    <content type="html"><![CDATA[<p>$\qquad$ 如题，该算法解决的问题就是计算一个无向图中有多少个三元环，采用的思想是根号分治。</p><p>$\qquad$ 考虑给所有边赋予一个方向，具体的，对于原图的每条边将度小的点指向度大的点，度相等的则将编号小的指向编号大的点来建一个新的有向图。由此得到的图是有向无环的。</p><p>$\qquad$ 证明：从一个点出发开始走，途径的点的度一定是非递减的，如果路径上点度都相等，点的编号一定是递增的，则其一定不会指向到达该点的路径上的点，所以新图一定是无环的。</p><p>$\qquad$ 如何计数？原图的三元环在新图中对应为满足 $u \rightarrow v, u \rightarrow w, v \rightarrow w$ 的三个点 $u, v, w$。考虑枚举所有边，这对应第一个条件，再枚举 $u$ 的所有出边，这对应第二个条件，是否满足第三个条件还需要再枚举 $v$ 的所有出边判断，在枚$u$ 的出边时给所有点打上一个时间戳，这样就可以在枚举 $v$  的时候 $O(1)$ 判断是否满足第三个条件。</p><p>复杂度证明：</p><p>$\qquad$ 由上述可得复杂度为 $\sum_{i &#x3D; 1}^m(d_u + d_v)$ , 其中 $d_i$ 表示点 $i$ 在新图中的度，通过分类讨论可以证明 $d_i$ 最大不超过 $\sqrt m$ 。设在原图中点 $i$ 的度数为 $deg_i$ ，当 $deg_u &lt;&#x3D; \sqrt m$ ，自然满足 $d_u &lt;&#x3D; \sqrt m$ 。当 $deg_u &gt; \sqrt m$ 时，由于我们建新图的方式，它在新图中的终点 $v$ 必定满足 $deg_v &gt;&#x3D; deg_u$ ，因为总边数为 $m$ ，则 $v$ 的数量不超过 $\frac{m}{\sqrt m}$ 个，所以复杂度就是 $m \sqrt m$。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> cas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    g = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (n + <span class="number">10</span>);</span><br><span class="line">    set&lt;pii&gt; ens;</span><br><span class="line">    vector&lt;pii&gt; edg;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (u == v || ens.<span class="built_in">count</span>(&#123;u, v&#125;)) <span class="keyword">continue</span>;</span><br><span class="line">        edg.<span class="built_in">pb</span>(&#123;u, v&#125;);</span><br><span class="line">        ens.<span class="built_in">insert</span>(&#123;u, v&#125;);</span><br><span class="line">        d[u]++, d[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edg.<span class="built_in">size</span>(); i++) </span><br><span class="line">        <span class="keyword">if</span> (d[edg[i].fi] &lt;= d[edg[i].se]) g[edg[i].fi].<span class="built_in">pb</span>(edg[i].se);</span><br><span class="line">        <span class="keyword">else</span> g[edg[i].se].<span class="built_in">pb</span>(edg[i].fi);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edg.<span class="built_in">size</span>(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = edg[i].fi, v = edg[i].se;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : g[u]) vis[w] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : g[v]) </span><br><span class="line">            <span class="keyword">if</span> (vis[w] == u) res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$&#92;qquad$ 如题，该算法解决的问题就是计算一个无向图中有多少个三元环，采用的思想是根号分治。&lt;/p&gt;
&lt;p&gt;$&#92;qquad$ 考虑给所有边赋予一个方向，具体的，对于原图的每条边将度小的点指向度大的点，度相等的则将编号小的指向编号大的点来建一个新的有向图。由此得到的图是</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
